아래는 원본 내용을 **전혀 변경하지 않고**, 복사하여 사용하기 쉽게 **마크다운 형식으로만 보기 좋게 꾸민 것**입니다.

---

# 📅 2025-03-04 화
- DB를 설계할 때 중복을 제거하는 것이 제일 중요하다는 것을 배웠습니다.

---

# 📅 2025-03-05 수
- 테이블을 설계할 때에는 한 칸에 한 개의 정보만 들어가도록 만들기
- 어떤 테이블에 FK를 넣어도 한 칸에 한 개 이상의 정보가 들어가면 중간 테이블을 만들자

---

# 📅 2025-03-06 목
- TCP는 연결지향으로 3way handshake로 가상연결을 해서 데이터 전달을 보증하고 순서를 보장한다.
- UDP는 IP와 같이 기능이 거의 없어서 단순하고 빠르다.
- PORT는 같은 IP 내에서 프로세스를 구분한다.
- 0 ~ 65535 까지 할당이 가능하지만 0~1023까지는 잘알려진 포트라서 사용하지 않는 것이 좋다.
- DNS는 전화번호부와 같이 변하는 IP에 대응해서 도메인 명을 IP 주소로 변환한다.

### 🌐 웹 브라우저 요청 흐름
- 웹 브라우저 요청은 웹 브라우저에서 HTTP 요청 메세지를 생성해서 전송을 하면
- socket 라이브러리를 통해서 TCP 3way handshake를 통해서 서버와 연결을 하고 TCP/IP로 데이터를 전달한다
- 그러면 HTTP 메시지를 포함한 TCP/IP 패킷을 생성하고 (이 패킷에 출발지 IP, PORT와 목적지 IP, PORT가 포함된다.)
- 서버로 패킷을 보낸다.
- 서버에서는 이 패킷을 까서 안의 HTTP 메시지를 확인한다.
- 그 다음 서버에서 HTTP 응답 메시지를 만들어서 똑같이 응답 패킷을 만들어서 웹 브라우저로 보낸다.

---

# 📅 2025-03-07 금

### 📌 HTTP
- 1997년에 나온 HTTP/1.1을 가장 많이 사용
- HTTP/1.1은 TCP를 기반 프로토콜로 사용
- 클라이언트 서버구조로 동작
- 무상태 프로토콜(스테이트리스)을 지향
- 비연결성
- HTTP 메시지를 통해서 통신
- 단순하고 확장이 가능

### 📌 클라이언트 서버 구조
- Request Response 구조
- 클라이언트가 서버에 요청을 보내고 기다리면 서버가 요청에 대한 결과를 응답
- 클라이언트와 서버가 분리되는 것이 중요
- 클라이언트는 UI/UX에 집중
- 서버는 비지니스 로직과 데이터
- 이러면 클라이언트와 서버가 각각 독립적으로 진화가능

### 📌 Stateful, Stateless
- 무상태 프로토콜 Stateless
  - 서버가 클라이언트의 상태를 보존하지 않는 것
  - 서버 확장성이 높지만(스케일 아웃) 클라이언트가 추가 데이터를 전송해야함
- Stateful은 상태를 유지하는 것
- 즉 Stateful은 가게의 점원 한 명 한테 계속 서비스 받는 것이고 Stateless는 중간에 다른 점원으로 바뀌어도 문맥을 보존하지 못하는 것
- Stateless 상태에서 제대로된 동작을 하고 싶으면 필요한 정보를 모두 포함해서 알려줘야함
- 정리하면 Stateful은 중간에 다른 점원으로 바뀌면 안되지만 Stateless는 중간에 다른 점원으로 바뀌면 안되지만 Stateless는 중간에 다른 점원으로 바뀌어도 된다
- 로그인과 같이 어쩔 수 없이 Stateful을 사용해야 하는 것을 제외하고는 Stateless를 사용하는 것이 좋다

---

# 📅 2025-03-10 월

### 🔔 Webhook
- 웹훅은 웹페이지 or 웹앱에서 발생하는 이벤트들을 커스텀 Callback으로 변환해주는 방법
- 이러한 행동 정보들을 실시간으로 제공하는데 사용
- 서버에서 특정 이벤트가 발생했을 때 웹훅을 통해 알림을 보냄

---

# 📅 2025-03-11 화

### 🔗 Connectionless (비연결성)
- HTTP는 기본적으로 연결을 유지하지 않는 모델
- 일반적으로 초 단위 이하의 빠른 속도로 응답
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
- 서버 자원을 매우 효율적으로 사용가능
- TCP/IP 연결을 새로 맺어야해서 3 way handshake 시간이 추가된다는 단점이 있음
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만아니라 자바스크립트, css, 추가 이미지 등등 수 많은 자원이 함께 다운로드됨
- 현재는 HTTP 지속연결(Persistent Connections)로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화

### 📩 HTTP 메시지
- HTTP 메시지 구조
  - start-line 시작 라인
  - header 헤더
  - empty line 공백 라인(CRLF)
  - message body

- 요청 메시지
  - 시작라인 = request-line
  - request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)
  - HTTP 메서드 (GET: 조회)
  - 요청 대상 (`/search?q=hello&hl=ko`)
    - absolute-path[?query] (절대경로[?쿼리])
    - 절대경로 = "/"로 시작하는 경로
  - HTTP Version
  - 예시: `GET /search?q=hello&hl=ko HTTP/1.1`

- 응답 메시지
  - 시작 라인 = status-line
  - status-line = HTTP-version SP status-code SP reason-phrase CRLF
  - HTTP 버전
  - HTTP 상태 코드: 요청 성공, 실패를 나타냄
    - `200`: 성공
    - `400`: 클라이언트 요청 오류
    - `500`: 서버 내부 오류
  - 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글

- HTTP 헤더
  - header-field = field-name":" OWS field-value OWS (OWS : 띄어쓰기 허용)
  - field-name은 대소문자 구분 없음
  - 예시: `Host: www.google.com`
  - 용도
    - HTTP 전송에 필요한 모든 부가정보
    - 표준 헤더가 너무 많음
    - 필요시 임의의 헤더 추가 가능

- HTTP 메시지 바디
  - 실제 전송할 데이터
  - byte로 표현할 수 있는 모든 데이터 전송 가능

- 단순함 확장 가능
  - HTTP는 단순하다.
  - HTTP 메시지도 매우 단순하다.
  - 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술

---

# 📅 2025-03-12 수

### 🖱 무선 마우스 동작 원리
- 무선 마우스는 내부 광학 센서가 움직임을 감지해 이를 디지털 데이터로 변환하고, 2.4GHz RF 전파를 통해 리시버로 전송
- 리시버는 주파수 필터링 및 디지털 신호 처리를 통해 해당 데이터를 복원하여 컴퓨터에 전달함으로써, 사용자의 입력을 인식

---

# 📅 2025-03-13 목

### 📚 역정규화
- 성능 향상을 위해 정규화된 DB를 다시 중복을 허용하는 형태로 변경하는 과정
- 정규화된 테이블 구조에서 SQL문 자체를 최대한 고쳐봐도 성능이 개선되지 않을 때 역정규화를 고려
- 매우 제한적으로 사용해야하고 데이터 중복으로 인해 실수로 데이터가 잘못 관리되는 현상(이상현상)이 발생하지 않도록 주의
- DB설게를 자유자재로 할 수 있고, 서비스를 배포해본 경험도 어느 정도 쌓였을 때쯤 고려해보기

### 💽 Mysql 기준 추천 데이터타입
- 정수를 저장해야 하는 경우 : `INT`
  - 휴대폰 번호는 숫자가 아닌 문자로 저장
  - 비슷한 예로 주민등록번호도 있음
  - 계산에서 쓰는 값인지 안 쓰는 값인지를 생각
- 10억이 넘어가는 정수를 저장해야 될 수도 있는 경우 : `BIGINT`
- 실수를 저장하고 싶은 경우 : `DECIMAL`
- 문자를 저장해야 하는 경우 : VARCHAR(글자수)
- 6만이 넘어가는 문자를 저장해야 하는 경우 : LONGTEXT
- TimeZone을 고려하지 않고 날짜 데이터만 저장하면 되는 경우 : `DATETIME`
  - ex) 국내 서비스
- TimeZone을 고려하면서 날짜 데이터를 저장해야 하는 경우 : `TIMESTAMP`
  - ex) 글로벌 서비스
- True, False의 형태를 저장하고 싶은 경우 : `TINYINT(1)`

---

# 📅 2025-03-14 금

### 🖥 운영체제란?
- 컴퓨터 시스템의 핵심 소프트웨어로, 컴퓨터 하드웨어와 응용 프로그램 간의 상호작용을 관리하고 제어하는 역할
- 사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용 프로그램이 동작하도록 지원
- 시스템 자원을 효율적으로 관리하여 응용 프로그램이 원활하게 동작
- 운영체제의 역할
  - 자원 관리
  - 메모리 관리
  - 프로세스 관리
  - 디스크 및 파일 시스템 관리
  - 입출력 관리
  - 사용자 인터페이스
  - 네트워킹
  - 오류처리
  - 시스템 보안
- 운영체제 종류
  - 윈도우
  - 맥OS
  - 리눅스
  - 유닉스

---

# 📅 2025-03-17 월

### ⚒ Mybatis
- DB와의 연동, 저장을 위한 기술
- SQL Mapper로 개발자가 작성한 SQL 실행 결과를 객체에 매핑
- 반복적인 JDBC 프로그래밍을 단순화하여, 불필요한 Boilerplate(반복적으로 비슷한 형태를 띄는 코드)코드를 제거
- Java 소스 코드에서 SQL 문을 분리하여 별도의 XML 파일로 저장하고, 서로 연결시켜주는 기능을 제공
- 동적 SQL 기능과 명시적 매핑은 복잡한 데이터 구조를 효과적으로 처리
- SQL을 XML 파일이나 어노테이션으로 직접 작성하므로, ORM이 내부적으로 생성하는 SQL보다 실행되는 쿼리를 명확하게 파악
- 개발자가 직접 SQL을 최적화할 수 있어 세밀한 성능 조정이 가능
- 기존 데이터베이스 스키마와 맞춰 직접 SQL을 작성하므로, 레거시 시스템과의 통합이 상대적으로 수월

---

# 📅 2025-03-18 화

### 🚗 Test-Driven Development
- 먼저 테스트를 작성하고, 작성한 테스트에 통과하도록 실제 코드를 작성하는 방법
- 애자일 방법론 중 하나인 eXtream Programming의 Test-First 개념에 기반을 둔 단순 설계를 강조
- TDD 방식으로 코드를 작성하는 방법 = red-green 테스트
  - 코드 작성 전에 실패하는 테스트 코드(레드)를 작성
  - 코드 작성 후에는 테스트가 통과(그린) 하는지 확인
  - 중요한 것은 실패하는 테스트 코드를 작성하기 전가지는 개발에 착수하지 않는 것
  - 또한 실패하는 테스트를 통과할 수 있을 정도의 실제 코드를 최소한 작성해야 하는 것
  - 그 후 통과하면 리팩토링
  - 반복
- 왜 이러한 방식을 사용하는가?
  - 코드를 성공적으로 작성하여 기능 구현을 완료했을 경우, 테스트를 번거로운 일처럼 느끼지 않게 됨
  - 기능 구현 전에 테스트 코드를 작성하면, 코드를 변경할 시 그와 관련된 테스트가 자동으로 실행
  - 따라서 개발을 진행하면서 모든 테스트를 작성해두면 변경 사항이 발생할 때마다 이를 재실행하며 자동으로 테스트를 진행

---

# 📅 2025-03-19 수

### 🎆 Firebase
- 구글이 소유하고 있는 모바일 애플리케이션 개발 플랫폼
- 파이어베이스를 활용하면 앱을 개발하고, 개선하고 더욱 키워나갈 수 있음
- 파이어베이스로 만든 서비스들이 클라우드에 호스팅되면 개발자의 입장에서는 거의 아무런 노력을 들이지 않고도 앱의 규모를 확장할 수 있음
- 파이어베이스가 제공하는 클라이언트 SDK가 백엔드 구성요소들과 직접 상호작용하며 우리가 만든 앱과 서비스 사이에 미들웨어 구축이 필요없음
- 일반적으로 클라이언트 앱에서 DB에 쿼리를 전송하는 코드를 작성하는데 파이어베이스를 이용하면 이러한 백엔드 작업을 건너뛰고, 그 일을 클라이언트 쪽으로 넘길 수 있음
- 이러한 관리자 기능은 파이어베이스의 콘솔창을 통해서 수행할 수 있음

---

# 📅 2025-03-20 목

### 🎢OSI7계층
- 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것
- 1계층 물리계층(Physical Layer)
  - 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송
  - 데이터가 무엇인지, 어떤 에러가 있는지는 신경쓰지 않음
  - 통신 케이블, 리피터, 허브 등이 있음
- 2계층 데이터 링크계층(DataLink Layer)
  - 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할
  - 통신에서의 오류도 찾아주고 재전송도 하는 기능을 가짐
  - 맥 주소를 가지고 통신
  - 브릿지나 스위치 등이 여기에 속함
  - 프레임에 주소를 부여(Mac - 물리적 주소)
- 3계층 네트워크 계층(Network Layer)
  - 데이터를 목적지까지 가장 안전하고 빠르게 전달(라우팅)
  - 주소부여(IP), 경로설정(Route)
- IP 계층
  - TCP/IP 상에서 IP 계층이란 네트워크의 주소(IP 주소)를 정의하고, IP 패킷의 전달 및 라우팅을 담당하는 계층
- IP 프로토콜
  - IP 게층에서 IP 패킷의 라우팅 대상
  - IP 주소 지정
  - 신뢰성(에러제어) 및 흐름제어 기능이 없음
  - 신뢰성을 확보하려면 IP 계층 위의 TCP와 같은 상위 트랜스포트 계층에 의존
- 4계층 전송 계층(Transport Layer)
  - 통신을 활성화하기 위한 계층
  - 보통 TCP 프로토콜을 이용
  - 포트를 열어서 응용프로그램들이 전송을 할 수 있게 함
  - 데이터가 왔다면 4계층에서 해당 데이터를 하나로 합쳐서 5계층에 던져줌
  - 단대단 오류제어 및 흐름제어 이 계층 까지는 물리적인 계층에 속함
  - 연결기반(connection oriented)
  - 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것
  - 패킷 생성 및 전송
- TCP 프로토콜(Transmission Control Protocol)
  - 신뢰적인 전송을 보장
  - 신뢰성이 있음
  - 연결지향적
- UDP 프로토콜(User Datagram Protocol)
  - 신뢰성이 낮은 프로토콜
  - 비연결성, 신뢰성이 없음, 순서화되지 않은 Datagram 서비스 제공
  - 실시간 응용 및 멀티 캐스팅 가능
  - 헤더가 단순함
- 5계층 세션 게층(Session Layer)
  - 데이터가 통신하기 위한 논리적인 연결
  - 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정등을 수행
  - TCP/IP 세션을 만들고 없애는 책임을 짐
- 6계층 표현계층(Presentation Layer)
  - 데이터 표현이 상이한 으용 프로세스의 독립성을 제공하고, 암호화
  - 사용자의 명령어를 완성 및 결과 표현, 포장, 압축, 암호화
- 7계층 응용계층(Application Layer)
  - 응용 서비스를 수행
  - 최종 목적지로 HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있음
  - 네트워크 소프트웨어 UI 부분, 사용자의 I/O 부분
- HTTP 프로토콜(HyperText Transfer Protocol)
  - 요청 및 응답 구조
  - 메세지 교환 형태의 프로토콜
  - 트랜잭션 중심의 비연결성 프로토콜

---

# 📅 2025-03-21 금

### 📅영속성 컨텍스트
- 영속성 컨텐스트란 엔티티를 영구 저장하는 환경이라는 뜻
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할
- 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리

---

# 📅 2025-03-24 월

### 🎫운영체제 2
- 운영체제는 특별한 프로그램이라서 항상 컴퓨터가 부팅될 때 메모리 내 **커널영역**이라는 공간에 따로 적재되어 실행
- 커널영역을 제외한 나머지 영역, 사용자가 이용하는 응용프로그램이 적재되는 영역을 **사용자 영역**이라 함
- 운영체제는 커널 영역에 적재되어 사용자 영역에 적재된 프로그램들에 자원을 할당하고 이들이 올바르게 실행되도록 도움
- 응용프로그램과 하드웨어 사이에서 응용프로그램에 필요한 자원을 할당하고, 응용프로그램이 올바르게 실행되도록 관리하는 역할

---

# 📅 2025-03-25 화

### 📨 스프링 배치
- 로깅/추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너뛰기, 리소스 관리 등 대용량 레코드 처리에 필수적인 기능 제공
- 최적화 및 파티셔닝 기술을 통해 대용량 및 고성능 배치 작업을 가능하게 하는 고급 기술 서비스 및 기능을 제공
- 배치가 실패하여 작업을 재시작을 하면 실패한 지점부터 실행
- 중복 실행을 막기 위해 성공한 이력이 있는 배치는 동일한 파라미터로 실행시 exception이 발생

---

# 📅 2025-03-26 수

### ⏰FCM(Firebase Cloud Messaging)
- 무료로 메시지를 전송할 수 있는 교차 플랫폼 메시징 솔루션
- 플랫폼에 종속되지 않고 푸쉬 메시지를 전송할 수 있음
- 서버를 경유하면 항상 서버에 접속해 있어야 해서 기기의 배터리와 네트워크 리소스를 크게 낭비
- 클라우드 메시징 서버를 중간에 둠으로써, 낮은 배터리와 네트워크의 사용만으로 메시지를 실시간으로 송수신 처리 가능

---

# 📅 2025-03-27 목

### 🧱소나큐브
- 정적코드분석으로 자동 리뷰를 수행하기 위한 지속적인 코드 품질 검사용 오픈 소스 플랫폼
- 중복코드, 코딩 표준, 유닛 테스트, 코드 커버리지, 코드 복잡도, 주석, 버그 및 보안 취약점의 보고서를 제공

---

# 📅 2025-03-31 월

### 🎭Inversion of Control
- 제어의 역전
- 객체의 의존성을 역전시켜서 객체간의 결합도를 줄이고 유연한 코드를 작성
- 가독성 및 코드 중복, 유지보수 편리
- 기존 객체 생성
  - 객체 생성 -> 의존성 객체 생성(클래스 내부에서 생성) -> 의존성 객체 메소드 호출
- 스프링
  - 객체 생성 -> 의존성 객체 주입(제어권을 스프링에 위임하여 스프링이 만들어 놓은 객체를 주입) -> 의존성 객체 메소드 호출
- 제어의 흐름을 사용자가 컨트롤 하는 것이 아니라 스프링에게 맡겨 작업을 처리

---

# 📅 2025-04-03 목

### ✨Java AWT와 Swing
- AWT(Abstract Windowing Toolkit)
  - 많은 GUI 컴포넌트를 포함한 패키지
  - AWT의 컴포넌트들은 중량 컴포넌트로 불린다.
  - 운영체제의 도움을 받아 화면에 출력되기 때문에 운영체제의 자원을 많이 소모하여 운영체제에 부담을 줌
- Swing
  - 순수 자바 언어로 작성
  - 운영체제의 도움을 받지 않기 때문에 스윙 컴포넌트들은 경량 컴포넌트라고 불린다.
  - 스윙 컴포넌트의 이름은 AWT 컴포넌트와 구분하기 위해 모두 대문자 J로 시작
  - 화려하며 다양한 모양의 GUI 응용 프로그램을 쉽게 개발할 수 있음
  - AWT에 구현된 이벤트 처리나 GUI 컴포넌트의 기본 원리를 바탕으로 작성
  - 사용하기 위해선 AWT 패키지가 필요

---

# 📅 2025-04-07 월

### ✨DI(Dependency Injection)
- 의존성 주입
- 프로그램의 부분적인 전환을 쉽게 만드는 것
- 사용되는 객체를 사용하는 객체 외부에서 생성하여 전달받는 사고방식
- 사용되는 객체를 의존객체
- 사용하는 객체에 의존 객체를 전달하는 것을 주입이라고 표현
- 프로덕션 환경에서 사용하는 클래스와 테스트 환경에서 사용하는 클래스를 나누는 것이 대표적인 예

---

# 📅 2025-04-08 화

### 🖥 인터넷
- 구성요소로 본 인터넷 1
  - 전 세계적으로 수십억 개의 컴퓨팅 장치를 연결하는 컴퓨터 네트워크
  - 인터넷에 연결되는 많은 비전통적인 장치들을 모두 인터넷 용어로 **호스트** 혹은 **종단 시스템(end system)**이라고 부름
  - 종단 시스템은 **통신 링크(communication link)**와 **패킷 스위치(packet switch)**의 네트워크로 연결
  - 각각의 통신 링크들은 다양한 **전송률(transmission rate, 링크 대역폭)**을 이용하여 데이터를 전송
    - 초당 비트 수를 의미하는 bps(bit per second)단위를 사용
  - 한 종단 시스템이 다른 종단 시스템으로 보낼 데이터를 갖고 있을 때, 송신 종단 시스템은 그 데이터를 세그먼트(segment)로 나누고 각 세그먼트에 헤더를 붙임
  - 이렇게 만들어진 정보 패키지를 컴퓨터 네트워크에서 **패킷(packet)**이라 부름
  - 패킷은 목적지 종단 시스템으로 네트워크를 통해 보내짐
  - 목적지에서 원래 데이터로 다시 조립

---

# 📅 2025-04-09 수

### 📂 Java Map 자료구조
- Key로 Value를 한 쌍으로 갖는 자료형
- 사전과 비슷함
- 리스트나 배열처럼 순차적으로 해당 요소 값을 구하지 않고 Key를 통해 Value를 얻음
- 리스트와 마찬가지로 인터페이스임
- Map 자료형에 HashMap, LinkedHashMap, TreeMap 등이 있음
- HashMap
  - 데이터 정렬이 없음
- TreeMap
  - 정렬 기준이 있음
  - 순서가 중요한 클레스이므로 순서에 관련된 메서드들이 있음
- LinkedHashMap
  - 데이터를 입력된 순서대로 관리해서 데이터의 순서를 보장

---

# 📅 2025-04-10 목

### 🎋 Spring MVC 흐름
- 요청된 URL을 dispatcher-servlet으로 전달
- 핸들러 매핑은 해당 URL에 매핑된 컨트롤러가 있는지 검사 후 컨트롤러에 전달
- 해당 컨트롤러가 로직을 처리
- ModelAndView 객체 생성 후, 로직의 결과를 담아서 dispatcher-servlet에 전달
- dispatcher-servlet은 전달 받은 뷰가 있는지 검사하기 위해 ViewResolver로 보냄
- ViewResolver는 받은 뷰가 있는지 검사 후 뷰로 보냄
- 모델과 같이 뷰를 그린 후에 dispatcher-servlet으로 보냄
- 최종적으로 컨텐츠를 클라이언트에게 전달
- dispatcher-servlet
  - Http 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러