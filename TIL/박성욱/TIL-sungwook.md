# 박성욱 - TIL

# 2025-03-04 (아이디어 회의)

- **핀테크와 관련된 아이디어 제시**:

  - 자동 저축과 소비 습관 개선을 위한 프로젝트 아이디어를 제시하고 토론하였습니다.

- **실용성과 창의성의 조율**:
  - 실용성만 추구하면 특색없는 프로젝트가 되고 창의성만 추구하면 실제 사용할 수 없는 프로젝트가 되기에 이 둘을 적절히 조율하여 프로젝트를 기획하는 것이 중요하다는 것을 배웠습니다.

# 2025-03-05 (아이디어 피드백)

- **핀테크 아이디어 컨설턴트님 피드백**:

  - 컨설턴트님 피드백을 받아 다양한 저축 방안을 추가로 논의하여 저축 장려 프로젝트로 구체화하였습니다.

- **팀원들과의 조율**:
  - 회의 중 팀원들과 의견을 조율하는 과정을 통해 다양한 의견을 반영하고 통합하는 능력을 키울 수 있었습니다.

# 2025-03-06 (아이디어 픽스)

- **프론트엔드 초기설정**:

  - 프로젝트의 주제가 픽스되었기에 본격적인 개발준비를 위해 초기설정을 진행하였습니다.
  - 이전 프로젝트에서는 vite를 사용했고 상태 관리 라이브러리는 redux를 사용했으나 이번에는 Recoil을 사용하기로 하였습니다.

- **Recoil이란?**:

  - Recoil : React의 전역 상태 관리 라이브러리
  - Redux보다 설정이 간단하고 React의 useState와 비슷하게 사용할 수 있습니니다.

- **Recoil의 주요 개념**:
- Atom: 상태의 단위 (useState처럼 개별 상태를 저장)
- Selector: 상태를 가공하는 함수 (파생 상태)
- RecoilRoot: Recoil을 사용하는 최상위 컴포넌트

# 2025-03-07 (React 학습 내용)

### useReducer를 활용한 상태 관리

React에서 상태를 관리할 때 가장 많이 사용하는 것은 `useState`이지만, 상태가 복잡해질 경우 `useReducer`가 더 적합하다. `useReducer`는 `reducer` 함수를 통해 상태를 업데이트하며, `dispatch`를 이용해 명확하게 상태 변화를 관리할 수 있다. 특히, 여러 개의 상태를 다룰 때 `useReducer`는 가독성과 유지보수성을 높여준다. 예를 들어, 단순한 카운터 기능이 아니라 여러 개의 버튼을 통해 다양한 액션을 수행해야 하는 경우 `useReducer`가 유용하다. 상태 변경 로직을 컴포넌트 내부가 아닌 `reducer` 함수에서 관리하기 때문에 코드가 더욱 깔끔해지고 예측 가능성이 높아진다.

# 2025-03-10 (React 학습 내용 2)

### React Router의 동적 라우팅

React에서 페이지 이동을 구현할 때 `react-router-dom`을 활용하면 손쉽게 클라이언트 사이드 라우팅을 설정할 수 있다. 특히, 동적 라우팅을 사용하면 특정 데이터를 URL에서 받아와 화면을 렌더링할 수 있다. 예를 들어, 유저 프로필 페이지에서 `user/1`, `user/2`와 같이 URL에 따라 다른 데이터를 표시할 수 있다. 이를 위해 `useParams`를 활용하면 URL의 특정 값을 가져와 해당 데이터를 렌더링할 수 있다. 또한, `<Link>` 컴포넌트를 이용하면 새로고침 없이 부드럽게 페이지를 이동할 수 있어 사용자 경험이 향상된다.

# 2025-03-11 (UX & UI 디자인)

## UX 및 UI 디자인 개요

피그마를 이용하여 와이어프레임 제작을 시작하려고 하니 UX & UI 디자인에 대한 이해가 필요할 것 같아 학습하였습니다.

## UX 디자인 (사용자 경험 디자인)

UX 디자인은 사용자가 제품, 서비스 또는 시스템과 상호작용할 때 경험하는 전체적인 느낌과 만족도를 다룹니다.

### 핵심 요소:

- **사용자 리서치**: 타겟 사용자의 니즈, 행동, 목표 이해
- **정보 구조**: 콘텐츠와 기능을 논리적으로 구성
- **와이어프레임**: 기본 레이아웃과 구조 설계
- **사용성 테스트**: 사용자가 제품을 사용하는 방식 관찰 및 개선점 도출
- **반복적 개선**: 피드백을 통한 지속적인 디자인 개선

## UI 디자인 (사용자 인터페이스 디자인)

UI 디자인은 사용자가 디지털 제품과 상호작용하는 시각적, 상호작용적 요소에 초점을 맞춥니다.

### 핵심 요소:

- **시각적 디자인**: 색상, 타이포그래피, 이미지, 아이콘 등
- **레이아웃**: 화면 공간의 효율적 활용
- **반응형 디자인**: 다양한 기기에서의 적응형 인터페이스
- **애니메이션 및 전환**: 사용자 상호작용에 대한 시각적 피드백
- **일관성**: 전체 제품에 걸친 통일된 디자인 언어

## UX와 UI의 관계

- UX는 전체적인 사용자 여정과 경험에 중점을 둡니다
- UI는 사용자가 제품과 상호작용하는 시각적 요소에 집중합니다
- 성공적인 제품을 위해선 두 분야 모두 중요하며 상호보완적입니다

## 디자인 프로세스

1. **리서치 및 분석**: 사용자, 경쟁사, 시장 조사
2. **정의 및 전략**: 목표, 페르소나, 사용자 여정 맵 설정
3. **아이디어 발상**: 브레인스토밍, 스케치
4. **디자인 및 프로토타입**: 와이어프레임, 목업, 프로토타입 제작
5. **테스트 및 평가**: 사용성 테스트, 피드백 수집
6. **출시 및 반복**: 제품 출시 후 지속적인 개선

## 좋은 UX/UI 디자인의 원칙

- 사용자 중심적 접근
- 명확성과 일관성
- 피드백과 응답성
- 효율성
- 접근성과 포용성
- 미학적 만족감

## 2025-03-12 (피그마 활용법)

### 피그마 개요 및 유용한 단축키

피그마는 웹 기반 UI/UX 디자인 도구로, 실시간 협업이 가능하며 디자인 작업을 효율적으로 수행할 수 있습니다.

#### 유용한 단축키:

- **기본 조작**:

  - 선택: V
  - 프레임 생성: F
  - 도형 그리기: R (사각형), O (원)
  - 텍스트: T
  - 이동: Space + 드래그
  - 줌: Ctrl/Cmd + 마우스 휠

- **편집 기능**:

  - 복사: Ctrl/Cmd + C
  - 붙여넣기: Ctrl/Cmd + V
  - 복제: Alt + 드래그
  - 그룹화: Ctrl/Cmd + G
  - 그룹 해제: Ctrl/Cmd + Shift + G

- **정렬 및 배치**:

  - 수평 정렬: Alt + A
  - 수직 정렬: Alt + V
  - 요소 간격 균등: Alt + H (수평), Alt + V (수직)

- **레이어 관리**:
  - 레이어 잠금/해제: Ctrl/Cmd + Shift + L
  - 숨기기/보이기: Ctrl/Cmd + Shift + H

### 피그마 활용 팁

- 컴포넌트 생성을 통해 재사용 가능한 UI 요소를 만들면 디자인 시스템을 효율적으로 구축할 수 있습니다.
- 오토 레이아웃 기능을 활용하면 반응형 디자인을 쉽게 구현할 수 있습니다.
- 프로토타이핑 기능을 통해 디자인의 흐름과 상호작용을 테스트할 수 있습니다.
- 플러그인을 활용하면 디자인 워크플로우를 더욱 향상시킬 수 있습니다.

## 2025-03-13 (Vite 초기 설정)

### Vite 개요

Vite는 최신 프론트엔드 개발 도구로, 빠른 개발 서버와 최적화된 빌드 기능을 제공합니다. React, Vue, Svelte 등 다양한 프레임워크를 지원하며, 특히 개발 환경에서의 빠른 HMR(Hot Module Replacement)이 특징입니다.

#### Vite의 주요 특징:

- 빠른 개발 서버 시작 시간
- 즉각적인 HMR(Hot Module Replacement)
- 최적화된 빌드 출력
- TypeScript 기본 지원
- CSS 전처리기 지원

#### React 프로젝트 초기 설정 방법:

1. Vite를 이용한 React 프로젝트 생성
2. 필요한 의존성 설치
3. 개발 서버 실행

#### 추가 라이브러리 설정:

- React Router 설치 (라우팅)
- Recoil 설치 (상태 관리)
- Axios 설치 (HTTP 클라이언트)

## 2025-03-14 (금융앱의 디자인 특징)

# 금융앱 디자인 특징 및 고려사항

오늘 현직자 멘토님과의 면담을 통하여 프로젝트의 개요와 와이어 프레임에 대한 피드백을 받았습니다. 또한, 현직자로서 금융앱을 개발할 때 고려해야 할 점을 배웠습니다. 배운 내용과 추가로 조사한 내용을 합쳐서 정리해보려 합니다.

## 개요

금융 애플리케이션은 사용자의 금융 정보를 다루는 민감한 서비스로, 보안성과 사용성 두 가지 측면을 모두 고려해야 합니다. 다양한 연령층을 고려한 직관적인 인터페이스, 빠른 로딩 시간, 그리고 강력한 보안 기능을 통합하여 사용자에게 신뢰감을 주는 것이 중요합니다. 특히 고령 사용자를 위한 접근성 개선과 3초 이내의 로딩 시간 확보, 그리고 적절한 자동 로그아웃 기능은 필수적인 요소입니다.

- **직관적인 인터페이스**: 다양한 연령대, 특히 고령 사용자를 위한 명확하고 단순한 UI 구성
- **가독성**: 충분한 폰트 크기와 색상 대비를 활용한 텍스트 가독성 확보
- **일관된 디자인 패턴**: 앱 전체에 걸쳐 일관된 네비게이션과 상호작용 패턴 유지
- **로딩 시간**: 3초 이내로 로딩 시간 제한 (초과 시 사용자 이탈률 증가)
- **점진적 로딩**: 중요 정보 먼저 표시, 나머지는 백그라운드에서 로딩
- **자동 로그아웃**: 일정 시간 이후 세션 종료 (보안 강화)
- **일관된 브랜드 아이덴티티**: 금융 기관의 신뢰감을 전달하는 컬러와 디자인 요소
- **전문성과 안정감**: 과도한 애니메이션이나 화려한 효과보다는 안정적인 느낌의 디자인

## 2025-03-17

# MyBatis란?

**MyBatis** : Java 애플리케이션에서 SQL을 쉽게 사용할 수 있도록 도와주는 SQL 매퍼 프레임워크  
Hibernate 같은 완전한 ORM과 달리, 개발자가 직접 SQL을 작성하면서 객체와 데이터베이스를 매핑할 수 있도록 지원합니다.

## MyBatis의 특징

**SQL을 직접 작성** → XML 파일이나 애노테이션을 사용해 명시적으로 SQL 관리 가능  
 **자동 매핑 지원** → SQL 결과를 Java 객체에 자동 매핑  
 **유연한 설정** → `mybatis-config.xml`을 통해 커넥션, 캐시, 로깅 등 설정 가능  
 **동적 SQL 지원** → `<if>`, `<foreach>` 같은 태그를 활용하여 동적 SQL 작성 가능  
 **트랜잭션 관리** → Spring과 함께 사용하면 트랜잭션 관리 가능

## MyBatis 동작 방식

**SQL 매퍼 작성** → XML 파일 또는 애노테이션을 활용하여 SQL 정의  
 **MyBatis 설정** → `mybatis-config.xml`에서 환경 설정  
 **SQL 실행** → `SqlSessionFactory`를 통해 SQL 실행 및 결과 매핑  
 **Java 객체로 반환** → SQL 실행 결과를 도메인 객체로 변환하여 사용

## 2025-03-18 (FCM 개요 및 구현 고려사항)

### Firebase Cloud Messaging (FCM) 이해하기

Firebase Cloud Messaging은 안정적이고 배터리 효율적인 앱 메시징 솔루션으로, 다양한 플랫폼에서 푸시 알림을 구현할 수 있게 해줍니다. 오늘은 FCM의 기본 개념과 구현 시 고려해야 할 점들에 대해 학습했습니다.

#### FCM의 주요 특징:

- 크로스 플랫폼 메시징 지원 (iOS, Android, 웹)
- 메시지 타입 구분 (알림 메시지, 데이터 메시지)
- 타겟팅 옵션 (개별 기기, 기기 그룹, 주제별)
- 분석 및 모니터링 기능 제공

#### 구현 시 고려사항:

- 토큰 관리: 사용자 기기 토큰의 안전한 저장 및 업데이트 메커니즘 구축
- 백그라운드/포그라운드 처리: 앱 상태에 따른 적절한 알림 처리 로직 구현
- 사용자 권한: 알림 권한 요청 시점과 방법에 대한 최적화 전략
- 알림 채널: Android 8.0 이상에서 필수적인 알림 채널 설계

## 2025-03-19 (Flutter 상태관리와 아키텍처)

### Flutter 앱 개발의 핵심 요소들

Flutter를 활용한 크로스 플랫폼 개발에서 효율적인 상태관리와 아키텍처는 앱의 성능과 유지보수성에 큰 영향을 미칩니다. 오늘은 Flutter 앱 개발 시 알아야 할 핵심 개념들을 정리했습니다.

#### Flutter의 상태관리 접근법:

- StatefulWidget: 기본적인 로컬 상태 관리 방식
- Provider: 간단하고 직관적인 의존성 주입 패턴
- Bloc/Cubit: 반응형 프로그래밍 기반의 상태관리
- Riverpod: Provider의 진화된 형태, 더 유연한 상태 관리
- GetX: 상태관리, 라우팅, 의존성 주입을 통합한 솔루션

#### Flutter 앱 아키텍처 패턴:

- 계층형 아키텍처: UI, 비즈니스 로직, 데이터 액세스 분리
- Clean Architecture: 의존성 규칙을 통한 코드 모듈화
- MVVM: ViewModel을 통한 UI와 비즈니스 로직 분리
- 단방향 데이터 흐름: 예측 가능한 앱 상태 변화

## 2025-03-20 (React Native의 성능 최적화)

### React Native 성능 최적화 전략

React Native는 자바스크립트로 네이티브 앱을 개발할 수 있는 강력한 프레임워크이지만, 최적화가 제대로 이루어지지 않으면 성능 이슈가 발생할 수 있습니다. 오늘은 React Native 앱의 성능을 최적화하는 방법들을 학습했습니다.

#### 렌더링 최적화:

- 불필요한 렌더링 방지: React.memo, useMemo, useCallback 활용
- 리스트 렌더링: FlatList와 VirtualizedList의 적절한 사용
- 이미지 최적화: 크기 조정, 캐싱, 점진적 로딩 구현

#### 자바스크립트 쓰레드 최적화:

- 무거운 연산 작업 분산: requestAnimationFrame 활용
- 코드 분할: 동적 임포트로 초기 로딩 시간 단축
- 메모리 누수 방지: 이벤트 리스너와 타이머 정리

#### 네이티브 브릿지 최적화:

- 브릿지 통신 최소화: 배치 처리와 네이티브 모듈 활용
- Hermes 엔진 활성화: 더 빠른 자바스크립트 실행 및 메모리 사용량 감소
- 네이티브 모듈 활용: 성능 중심적 기능의 네이티브 구현

## 2025-03-21 (React 컴포넌트 설계 원칙)

### 효율적인 React 컴포넌트 구성 전략

React 컴포넌트를 설계할 때는 재사용성, 유지보수성, 그리고 성능을 모두 고려해야 합니다. 오늘은 React 컴포넌트를 구성할 때 고려해야 할 핵심 원칙들을 정리했습니다.

#### 컴포넌트 설계 원칙:

- 단일 책임 원칙: 하나의 컴포넌트는 하나의 역할만 수행
- 컴포지션 활용: 상속보다 컴포지션을 통한 기능 확장
- 관심사 분리: 프레젠테이션 컴포넌트와 컨테이너 컴포넌트 구분
- Props API 설계: 직관적이고 일관된 props 인터페이스 설계

#### 성능 고려사항:

- 적절한 메모이제이션: useMemo와 useCallback의 효과적인 활용
- 렌더링 최적화: 불필요한 리렌더링 방지 전략
- 상태 관리 계층화: 전역/지역 상태의 효율적인 분리
- 지연 로딩: React.lazy와 Suspense를 활용한 코드 분할

#### 유지보수성 향상:

- 명확한 네이밍 컨벤션: 컴포넌트와 props 이름의 일관성 유지
- 문서화: 주석과 PropTypes/TypeScript를 통한 인터페이스 명세
- 테스트 용이성: 순수 함수 지향 및 의존성 주입 패턴 활용
- 코드 스타일 통일: ESLint와 Prettier를 통한 일관된 코드 스타일

# 2025-03-24 (데이터 구조와 알고리즘)

- **시간 복잡도와 공간 복잡도**:
  - 알고리즘의 효율성을 평가하는 두 가지 주요 지표로, 시간 복잡도는 실행 시간을, 공간 복잡도는 메모리 사용량을 분석합니다.
  - Big O 표기법(O(n), O(log n), O(n²) 등)을 통해 알고리즘의 성능을 표현합니다.

- **자료구조의 중요성**:
  - 적절한 자료구조 선택은 알고리즘의 성능을 좌우하며, 문제 해결의 핵심입니다.
  - 배열, 연결 리스트, 스택, 큐, 해시 테이블, 트리, 그래프 등 상황에 맞는 자료구조 선택이 중요합니다.

# 2025-03-25 (네트워크 기초)

- **OSI 7계층 모델**:
  - 네트워크 통신을 7개의 논리적 계층으로 분리한 모델로, 복잡한 네트워크 작동 방식을 이해하기 쉽게 만들어줍니다.
  - 물리(1), 데이터 링크(2), 네트워크(3), 전송(4), 세션(5), 표현(6), 응용(7) 계층으로 구성됩니다.

- **HTTP vs HTTPS**:
  - HTTP는 웹 통신의 기본 프로토콜이지만 데이터가 암호화되지 않아 보안에 취약합니다.
  - HTTPS는 SSL/TLS 암호화를 통해 데이터를 보호하며, 웹사이트의 신뢰성을 확인할 수 있는 인증서를 제공합니다.

# 2025-03-26 (운영체제 개념)

- **프로세스와 스레드**:
  - 프로세스는 실행 중인 프로그램의 인스턴스로, 독립된 메모리 공간을 가집니다.
  - 스레드는 프로세스 내에서 실행되는 작업 단위로, 같은 프로세스의 스레드들은 메모리 자원을 공유합니다.

- **메모리 관리**:
  - 가상 메모리는 물리적 메모리 크기의 제약을 극복하기 위한 기술입니다.
  - 페이징과 세그먼테이션은 메모리를 효율적으로 관리하는 기법으로, 메모리 단편화 문제를 해결합니다.

# 2025-03-27 (디자인 패턴)

- **디자인 패턴의 의미**:
  - 소프트웨어 설계에서 자주 발생하는 문제에 대한 재사용 가능한 해결책입니다.
  - 코드의 유지보수성, 확장성, 가독성을 높이는 데 도움이 됩니다.

- **주요 디자인 패턴 분류**:
  - 생성 패턴(Singleton, Factory, Builder 등): 객체 생성 메커니즘을 다룹니다.
  - 구조 패턴(Adapter, Decorator, Composite 등): 객체 구성을 통한 기능 확장을 다룹니다.
  - 행동 패턴(Observer, Strategy, Command 등): 객체 간 커뮤니케이션을 다룹니다.

# 2025-03-28 (데이터베이스 기초)

- **SQL vs NoSQL**:
  - SQL 데이터베이스는 정형화된 스키마와 관계형 모델을 사용하며, 데이터 무결성에 강점이 있습니다.
  - NoSQL 데이터베이스는 유연한 스키마를 가지며, 대규모 분산 데이터에 적합하고 수평적 확장성이 뛰어납니다.

- **인덱싱의 중요성**:
  - 데이터베이스 인덱스는 데이터 검색 속도를 향상시키는 자료구조입니다.
  - 인덱스는 검색 속도를 높이지만 삽입, 수정, 삭제 작업의 오버헤드가 증가하므로 적절한 균형이 필요합니다.

# 2025-03-31 (웹 보안 기초)

- **XSS(Cross-Site Scripting)**:
  - 공격자가 웹 페이지에 악성 스크립트를 삽입하여 사용자 데이터를 탈취하는 공격입니다.
  - 입력값 검증, 콘텐츠 보안 정책(CSP), 적절한 출력 인코딩으로 방어할 수 있습니다.

- **CSRF(Cross-Site Request Forgery)**:
  - 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 수행하게 하는 공격입니다.
  - CSRF 토큰, SameSite 쿠키 속성, Referer 검사 등으로 방어할 수 있습니다.

# 2025-04-01 (CI/CD 개념)

- **지속적 통합(CI)**:
  - 개발자들이 코드 변경사항을 중앙 저장소에 자주 병합하고 자동화된 빌드와 테스트를 실행하는 개발 방식입니다.
  - 통합 문제를 조기에 발견하고 해결하여 개발 품질을 향상시킵니다.

- **지속적 배포(CD)**:
  - 지속적 통합을 통과한 코드 변경사항을 자동으로 프로덕션 환경에 배포하는 방식입니다.
  - 수동 개입을 최소화하여 릴리스 주기를 단축하고 피드백 루프를 가속화합니다.

# 2025-04-02 (클라우드 컴퓨팅 기초)

- **IaaS, PaaS, SaaS 차이점**:
  - IaaS(Infrastructure as a Service): 가상 서버, 스토리지 등 기본 인프라를 제공합니다.
  - PaaS(Platform as a Service): 개발 및 배포 플랫폼을 제공하여 개발자가 인프라 관리 없이 애플리케이션에 집중할 수 있게 합니다.
  - SaaS(Software as a Service): 완전한 소프트웨어 솔루션을 서비스로 제공합니다.

- **클라우드 컴퓨팅의 이점**:
  - 확장성, 비용 효율성, 유연성, 재해 복구, 자동 업데이트 등 다양한 장점을 제공합니다.
  - 특히 트래픽 변동이 큰 서비스에서 필요에 따른 리소스 확장이 용이합니다.

# 2025-04-03 (코드 품질과 테스팅)

- **단위 테스트의 중요성**:
  - 코드의 개별 구성 요소를 독립적으로 테스트하여 기능 정확성을 검증합니다.
  - 회귀 오류를 방지하고, 코드 리팩토링 시 안전망 역할을 합니다.

- **코드 품질 지표**:
  - 복잡도, 중복, 응집도, 결합도 등 코드 품질을 측정하는 다양한 지표가 있습니다.
  - 정적 코드 분석 도구를 통해 코드 품질 문제를 조기에 발견하고 해결할 수 있습니다.

# 2025-04-04 (확장성 있는 시스템 설계)

- **수평적 확장 vs 수직적 확장**:
  - 수평적 확장(스케일 아웃): 서버 인스턴스 수를 늘려 처리량을 높입니다.
  - 수직적 확장(스케일 업): 서버의 성능(CPU, RAM 등)을 향상시켜 처리 능력을 높입니다.

- **로드 밸런싱**:
  - 여러 서버에 트래픽을 분산하여 시스템 성능을 최적화하는 기술입니다.
  - 라운드 로빈, 최소 연결, IP 해시 등 다양한 알고리즘을 사용할 수 있습니다.

# 2025-04-07 (자바스크립트 비동기 프로그래밍)

- **Promise와 async/await**:
  - Promise는 비동기 작업의 최종 완료(또는 실패)와 그 결과값을 나타내는 객체입니다.
  - async/await는 Promise를 기반으로 한 문법적 설탕으로, 비동기 코드를 동기 코드처럼 작성할 수 있게 해줍니다.

- **이벤트 루프의 이해**:
  - 자바스크립트는 싱글 스레드 언어이지만, 이벤트 루프를 통해 비동기 작업을 처리합니다.
  - 콜 스택, 태스크 큐, 마이크로태스크 큐의 상호작용을 이해하면 비동기 코드의 실행 순서를 예측할 수 있습니다.
  - Promise의 then/catch 핸들러는 마이크로태스크 큐에, setTimeout/setInterval 콜백은 태스크 큐에 배치됩니다.

# 2025-04-08 (마이크로서비스 아키텍처)

- **모놀리식 vs 마이크로서비스**:
  - 모놀리식은 모든 기능이 단일 코드베이스에 통합된 구조로, 개발 초기에 단순하지만 확장이 어렵습니다.
  - 마이크로서비스는 기능별로 독립된 서비스로 분리하여 개발, 배포, 확장이 용이하지만 복잡성이 증가합니다.

- **마이크로서비스의 과제**:
  - 서비스 간 통신, 데이터 일관성, 분산 트랜잭션 관리 등 새로운 문제가 발생합니다.
  - API 게이트웨이, 서비스 메시, 서킷 브레이커 등의 패턴으로 이러한 문제를 해결합니다.

# 2025-04-09 (프론트엔드 성능 최적화)

- **렌더링 최적화**:
  - 크리티컬 렌더링 패스 최적화를 통해 페이지 로딩 속도를 개선합니다.
  - 브라우저의 렌더링 과정(DOM 구성, 스타일 계산, 레이아웃, 페인트, 컴포지팅)을 이해하고 각 단계별 최적화 전략을 적용합니다.

- **웹 성능 지표**:
  - LCP(Largest Contentful Paint): 페이지의 주요 콘텐츠가 로드되는 시점을 측정합니다.
  - FID(First Input Delay): 사용자의 첫 상호작용에 대한 응답 시간을 측정합니다.
  - CLS(Cumulative Layout Shift): 시각적 안정성을 측정하는 지표로, 예상치 못한 레이아웃 변화를 줄여야 합니다.

# 2025-04-10 (컨테이너화와 Docker)

- **컨테이너의 개념**:
  - 애플리케이션과 그 종속성을 함께 패키징하는 경량화된 가상화 기술입니다.
  - 모든 환경에서 일관되게 실행되어 "내 컴퓨터에서는 작동했는데" 문제를 해결합니다.

- **Docker의 주요 구성 요소**:
  - Dockerfile: 이미지 빌드 지침을 정의합니다.
  - 이미지: 애플리케이션과 환경을 포함한 읽기 전용 템플릿입니다.
  - 컨테이너: 이미지의 실행 가능한 인스턴스입니다.
  - Docker Compose: 다중 컨테이너 애플리케이션을 정의하고 관리합니다.