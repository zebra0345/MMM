# 최종민 - TIL

## 2025-03-04 (PM 교육 + 아이디어 회의)

- **핀테크 도메인과 관련된 아이디어 제시**: 
  - 아이디어를 공유하고, 팀원들과 의견을 조율했습니다.

---

### 팀 구성원 갈등 관리

- 갈등을 다룰 때는 **감정**을 우선적으로 다루는 것이 중요합니다. 
  - 가치나 결과에 대한 언급보다 감정의 이해가 필요합니다.

---

### 의사 결정 전략

1. **문제 해결 및 협력**: 
   - 갈등 해결 노력을 최소화하는 방향으로 진행합니다.
   
2. **갈등 조정**:
   - 타협과 조화를 통해 갈등을 해결합니다.
   
3. **사소한 갈등**:
   - 회피하거나 지연시키는 전략을 사용합니다.
   
4. **팀장의 잘못**:
   - 잘못이 확실한 경우, 수용하고 수습하는 접근이 필요합니다.
   
5. **긴급한 상황**:
   - 강압적이거나 경쟁적인 방식으로 신속히 대응합니다.

---

### 갈등 관리 전략

- **다양한 전략 활용**: 
  - 하나의 갈등 관리 전략만을 사용하기보다는 상황에 따라 적절한 전략을 선택해야 합니다.

## 2025-03-05 (아이디어 회의)

- **팀 미팅 후 아이디어 회의**: 
  - 콘텐츠에 중심을 두기 보다는 문제 X를 해결하기 위해 어떤 기술을 적용할지가 우선이 되어야 한다.
  - 부족한 부분을 보강하였고, 팀원들과 의견을 조율해서 기획안을 작성하였습니다.

## 2025-03-06 (인증 방식)

### 세션 기반 인증

#### 작동 방식
1. 사용자가 로그인하면, 프론트엔드가 인증 정보를 백엔드 서버로 전송합니다.
2. 백엔드는 비밀 키를 사용해 세션을 생성하고, 세션 데이터를 데이터베이스나 세션 저장소에 저장합니다.
3. 서버는 고유한 세션 ID가 포함된 쿠키를 사용자의 브라우저로 전송합니다.
4. 이후의 요청에서 브라우저는 헤더에 세션 ID를 포함시켜 전송합니다.
5. 서버는 세션 ID를 검증하고 접근을 허용합니다.

#### 장점
- **세션 관리 용이**: 서버에서 사용자 상태를 직접 관리하여 보안성을 높일 수 있습니다.
- **중앙 집중식 관리**: 사용자 활동 추적과 제어가 편리합니다.
- **세션 유효 기간 설정**: 세션의 유효 기간을 설정하고 갱신할 수 있어 보안 관리가 용이합니다.

#### 단점
- **확장성 문제**: 사용자가 증가하면 세션 저장소가 병목 현상을 일으킬 수 있습니다.
- **서버 의존성**: 세션 상태 관리를 위해 항상 서버가 필요합니다.
- **상태 동기화 필요**: 서버 간 상태 동기화가 필요하여 로드 밸런싱이 어려울 수 있습니다.
- **서버 자원 소모**: 사용자가 많아질수록 세션 저장소의 자원이 소모되므로, 이를 관리하기 위한 추가적인 리소스가 필요할 수 있습니다.

---

### JWT (JSON Web Token)

#### 작동 방식
1. 사용자가 로그인하면 백엔드 서버가 인증을 수행합니다.
2. 서버는 개인 키로 서명된 JWT를 생성하며, 별도의 세션 저장소는 필요하지 않습니다.
3. JWT는 클라이언트의 브라우저로 전송됩니다 (주로 쿠키를 통해).
4. 이후 모든 요청에서 브라우저는 헤더에 JWT를 포함하여 전송합니다.
5. 서버는 JWT의 유효성을 검증하고, 토큰에서 사용자 정보를 추출합니다.

#### 장점
- **무상태 방식**: 별도의 세션 저장소가 필요 없어 수평적 확장이 용이합니다.
- **높은 이식성**: 백엔드 세션 저장소 공유 없이 여러 서비스와 도메인에서 사용할 수 있습니다.
- **자체 정보 포함**: 모든 정보는 JWT 자체에 포함되어 있어 서버는 토큰의 유효성만 검증하면 됩니다.

#### 단점
- **토큰 무효화 어려움**: 발급된 토큰을 만료 전에 강제로 무효화하기가 복잡합니다.
- **데이터 갱신 제한**: 토큰에 담긴 정보는 만료되기 전까지 업데이트할 수 없습니다.
- **페이로드 크기**: JWT는 포함된 정보량에 따라 크기가 커질 수 있어 네트워크 부하가 증가할 수 있습니다.

---

### 선택 기준

#### 세션을 사용해야 할 때
- 실시간 사용자 상태 관리와 즉각적인 세션 무효화가 중요한 경우 (예: 금융권).
- 사용자 관리의 단순성을 우선시하는 경우.
- 사용자 세션을 자주 업데이트하거나 변경하는 경우.

#### JWT를 사용해야 할 때
- 서비스의 확장성과 시스템 간 연동이 중요한 경우 (예: MSA나 많은 API 호출).
- 인증 처리의 서버 의존도를 최소화하고 싶은 경우.
- 모바일 애플리케이션과 같은 클라이언트와 서버 간의 통신이 빈번한 경우

---

## 세션 관리 및 정합성 고려사항

### 고민해야 할 점 (세션)

#### 1. Redis에서 세션 TTL 설정
- **자동 세션 만료**: 
  - 장시간 활동하지 않은 사용자의 세션을 자동으로 만료시켜, 세션을 탈취당하더라도 공격자가 더 이상 세션을 사용할 수 없게 됩니다.
  
- **불필요한 세션 제거**: 
  - 서버에 세션 데이터가 계속 쌓이는 것을 방지하여 리소스를 효율적으로 관리할 수 있습니다.

#### 2. HttpOnly 쿠키 사용
- **XSS 공격 방지**: 
  - 쿠키를 JavaScript에서 읽을 수 없으므로, XSS 공격을 통해 세션 쿠키를 탈취할 위험을 줄입니다.

### 세션의 정합성
세션의 정합성(Session Consistency)은 사용자의 세션 데이터가 일관되고 정확하게 유지되는 상태를 의미합니다. 즉, 사용자가 애플리케이션에 로그인하고 세션이 생성된 후, 해당 세션 내에서 수행하는 모든 작업(예: 정보 조회, 데이터 업데이트 등)이 일관된 상태로 관리되는 것입니다.

#### 1. Sticky Session
- **정의**: 
  - Sticky Session(세션 지속성)은 사용자의 요청이 항상 동일한 서버로 전달되도록 하는 로드 밸런싱 기법입니다. 사용자가 처음 접속한 서버에 계속해서 요청을 보내도록 하여 세션 데이터가 해당 서버의 메모리에 유지되도록 합니다.
  
- **장점**:
  - 세션 데이터가 특정 서버에 저장되므로, 세션 정합성 문제를 방지할 수 있습니다.
  - 세션 정보가 분산되지 않으므로 관리가 간편합니다.
  
- **단점**:
  - 특정 서버에 부하가 집중될 수 있으며, 해당 서버가 다운되면 세션 정보가 손실됩니다.
  - 서버 장애가 발생했을 때 사용자 경험이 저하될 수 있습니다.

#### 2. Redis
- **정의**: 
  - Redis와 같은 인메모리 데이터베이스를 사용하여 세션 정보를 외부에 저장하고 여러 서버 간에 공유할 수 있도록 합니다. Redis는 빠른 읽기/쓰기가 가능하므로 세션 정보를 효율적으로 관리할 수 있습니다.
  
- **장점**:
  - 세션 정보를 중앙 집중식으로 관리할 수 있어, 서버 간의 세션 정합성을 유지할 수 있습니다.
  - 서버가 장애가 발생하더라도, 세션 데이터가 Redis에 저장되어 있어 사용자가 다른 서버로 이동해도 세션을 유지할 수 있습니다.
  - 수평 확장이 가능하여, 트래픽이 많아져도 서버를 추가하여 부하를 분산할 수 있습니다.
  
- **단점**:
  - Redis의 설정 및 관리가 추가적으로 필요합니다.
  - 네트워크 지연이 발생할 수 있으며, Redis가 장애가 발생할 경우 세션 정보에 접근할 수 없게 됩니다.

## 2025-03-07 (생산성 향상 기법)

### 시간 관리 기법  
- **포모도로 기법 (Pomodoro Technique)**  
  - 25분 집중 + 5분 휴식 (4번 반복 후 15~30분 긴 휴식)  
  - 짧은 집중 시간을 활용해 생산성을 높임  

- **타임박싱 (Timeboxing)**  
  - 특정 작업에 할애할 시간을 미리 정해서 그 안에 끝내는 방식  

- **타임 블로킹 (Time Blocking)**  
  - 하루 또는 일주일의 일정에서 특정 시간을 블록으로 나누어 계획  

- **포커스 타임 (Focus Time)**  
  - 방해받지 않고 깊이 집중할 시간을 확보하는 것  
  - 주로 업무 일정에서 '회의 없는 시간'을 따로 확보하는 방식  

---

### 업무 관리 기법  
- **아이젠하워 매트릭스 (Eisenhower Matrix)**  
  - 업무를 **긴급 & 중요도**로 나누어 우선순위를 결정  
    - **긴급 + 중요** → 바로 실행  
    - **긴급 X + 중요** → 계획 세우기  
    - **긴급 + 중요 X** → 위임  
    - **긴급 X + 중요 X** → 제거  

- **GTD (Getting Things Done)**  
  - 할 일을 **수집 → 정리 → 실행 가능하게 분류 → 일정 관리 → 실행**  

- **만트라트 (Mandrat)**  
  - GTD의 보완 개념, **'오늘 해야 할 일'을 중심으로 일정 관리**  
  - 핵심은 **중요한 목표만 남기고, 꼭 필요한 일에만 집중**하는 것  

- **PARA 메서드**  
  - 디지털 업무 정리 방법, 정보와 할 일을 4가지로 분류  
    - **Projects (프로젝트)** → 현재 진행 중인 작업  
    - **Areas (영역)** → 지속적으로 관리해야 할 분야  
    - **Resources (자원)** → 미래에 참고할 정보  
    - **Archives (보관소)** → 완료한 프로젝트 저장  

---

### 정보 관리 기법  
- **제텔카스텐 (Zettelkasten)**  
  - 메모를 연결해서 지식을 쌓는 방법  
  - 모든 아이디어나 정보를 작은 메모(노트)로 정리하고, 서로 연결  
  - 마치 **'뇌 속 네트워크'**처럼 동작하며 깊이 있는 사고 가능  

## 2025-03-10 (ERD)
### 팀 프로젝트 고민할 점
- 금융 API와 우리 서비스를 분리할 것 인가?
- 분리하지 않는다면 입금 출금 계좌 어떻게 관리할 것인지?

---

### ERD 설계
### 1. 명확한 엔티티와 속성 정의  
- 데이터베이스의 정확성과 일관성을 보장하기 위해 **엔티티와 속성을 구체적으로 정의**해야 함.  
- 모호한 정의는 설계 오류로 이어질 수 있음.  

### 2. 정확한 엔티티 간 관계 설정  
- **엔티티 간의 관계를 명확하게 식별하고 표현**해야 함.  
- 논리적 구조를 올바르게 반영하는 것이 중요함.  

### 3. 단순하고 이해하기 쉬운 ERD  
- ERD는 **최대한 직관적으로 설계**하여 관리 및 이해를 용이하게 해야 함.  
- 불필요한 복잡성은 오류 가능성을 높일 수 있음.  

### 4. 정규화와 성능 고려  
- **데이터 중복을 최소화**하기 위해 정규화를 적용.  
- 하지만 성능 최적화를 위해 경우에 따라 **비정규화**를 고려할 수도 있음.  

### 5. 일관된 명명 규칙 적용  
- 엔티티 및 속성의 **명명 규칙을 일관되게 유지**해야 함.  
- 예: `user_id`, `order_id` 같은 명확한 네이밍 사용.  

### 6. 무결성 제약 조건 설정  
- 데이터의 정확성을 유지하기 위해 **PK, FK, UNIQUE 등의 제약 조건을 명확히 설정**해야 함.  
- 필요 시 **NOT NULL, CHECK 제약 조건**을 추가하여 데이터 무결성을 보장.  

### 7. 확장성과 유지보수성 고려  
- 향후 기능 확장 및 변경을 고려하여 **확장성이 높은 구조**를 설계.  
- 너무 제한적인 설계는 변경 시 많은 수정이 필요할 수 있음.  

### 8. 보안 및 접근 제어  
- 민감한 데이터(예: 사용자 비밀번호, 개인 정보)는 **암호화 및 접근 권한 제한** 필요.  
- **역할 기반 접근 제어(RBAC)** 등을 고려할 수 있음.  

---

## 2025-03-11 (내부 보안?)
### 세션 보안 강화? (더 생각해보기)

- 세션 고정 공격 방지
- 세션 하이재킹 방지
- 동시 로그인 제한
- CSRF 방지
- 세션 만료 시간 설정
- IP 기반 세션 보호

## 2025-03-12 (Redis)
### Redis
#### 1. 개념
Redis(Remote Dictionary Server)는 키-값(Key-Value) 구조의 오픈소스 인메모리 데이터 스토어로, 주로 **캐싱, 세션 관리, 메시지 브로커, 실시간 데이터 처리** 등의 용도로 사용된다.  
데이터를 메모리에 저장하여 빠른 읽기/쓰기 성능을 제공하며, 필요에 따라 **디스크에 영속성(Persistence)** 을 설정할 수도 있다.

#### 2. 특징
##### 초고속 성능
- 데이터가 메모리에 저장되므로, 읽기/쓰기 속도가 매우 빠름 (**밀리초 단위 응답**)

##### Key-Value 데이터 모델
- 단순한 키-값 저장뿐만 아니라 **리스트(List), 해시(Hash), 셋(Set), 정렬된 셋(Sorted Set)** 등 다양한 자료구조 지원

### 3. Redis를 사용해야 하는 경우
#### 캐싱 시스템
- 자주 조회되는 데이터를 Redis에 저장하여 **데이터베이스 부하 감소 및 응답 속도 향상**
- 예시: 로그인된 사용자 정보, 인기 게시글, 검색 결과 저장

#### 세션 관리
- 사용자 로그인 세션을 빠르게 조회하고 저장
- 예시: 웹 애플리케이션의 JWT 토큰, 세션 데이터 저장

---
## 2025-03-13 (검색 방법)
### Elasticsearch
### 1. 개념
- 분산형 검색 및 분석 엔진으로, JSON 기반의 RESTful API를 통해 데이터를 저장, 검색, 분석할 수 있는 강력한 검색 엔진

### 2. 주요 기능

#### 1. 실시간 검색 및 분석
- 데이터가 저장되자마자 즉시 검색 가능
- 키워드 기반 검색, 부분 검색(검색어 자동완성) 가능
#### 2. 강력한 필터링 및 집계
- 특정 조건에 맞는 데이터 필터링
- 통계, 평균, 합계 등의 집계 연산 지원
#### 3. 확장성 및 고가용성
- 여러 대의 서버에 데이터를 분산 저장 (클러스터링)
- 장애 발생 시 복제 샤드를 통해 데이터 보전
#### 4. RESTful API 지원
- JSON 기반의 API를 제공하여 다양한 애플리케이션과 연동 가능

---

## 2025-03-14 (데이터베이스)
### 1. 무결성
- 데이터가 변경되지 않고 일관성을 유지하는 것을 의미합니다.

- 정확성(Accuracy): 데이터가 오류 없이 저장되고 유지됨
- 일관성(Consistency): 데이터가 정해진 규칙과 제약 조건을 충족
- 신뢰성(Reliability): 인가되지 않은 변경이 발생하지 않음

### 2. 가용성
- 필요한 데이터가 사용자가 필요할 때 항상 접근 가능해야 함을 의미합니다.

- 고가용성(High Availability): 시스템이 장애 없이 지속적으로 운영됨
- 안정성(Reliability): 장애 발생 시 신속한 복구 가능
- 내결함성(Fault Tolerance): 장애가 발생해도 정상적으로 운영 가능

### 3. 기밀성
- 데이터가 인가된 사용자만 접근할 수 있도록 보호하는 것을 의미합니다.

- 접근 제어(Access Control): 권한이 있는 사용자만 데이터 접근 가능
- 암호화(Encryption): 데이터를 암호화하여 보호

## 2025-03-17 (메일)
### 1. SMTP
- 이메일을 보내는 데 사용되는 프로토콜이며, 클라이언트가 메일을 작성하면 SMTP 서버를 통해 목적지 서버로 전송된다.
- 587 STARTTLS를 이용한 보안 SMTP (포트를 사용한다 )

### 2. POP3
- 이메일을 서버에서 클라이언트로 가져오는 데 사용되는 프로토콜입니다. 서버에서 메일을 다운로드한 후 기본적으로 서버에서 삭제합니다.
- 995 SSL/TLS를 이용한 보안 POP3 ( 포트를 사용한다 )

### 3. IMAP
- 이메일을 서버에 저장하고 여러 기기에서 동기화할 수 있도록 지원하는 프로토콜입니다.
- 993 SSL/TLS를 이용한 보안 IMAP ( 포트를 사용한다 )

## 2025-03-18 (Spring)
### 1. RequestBody
- HTTP 요청의 본문에 담긴 데이터를 객체로 변환하여 전달받을 때 사용합니다. 주로 JSON, XML 같은 데이터를 처리할 때 사용되며, @RequestBody를 사용하면 Spring이 자동으로 객체로 변환해 줍니다.

### 2. RequestParam
- 쿼리 스트링 또는 폼 데이터를 처리할 때 사용됩니다. 일반적으로 GET 요청에서 URL 파라미터를 받을 때 사용됩니다

### 3. 차이
- @RequestParam과 마찬가지로 요청 파라미터를 객체로 바인딩하기 위해 사용됩니다. 하지만 어떤 것을 바인딩하는 것에 대해 @RequestParam과 @RequestBody의 차이가 있습니다. @RequestParam은 URL에 요청 파라미터를 바인딩하지만 , @RequestBody는 Http Body에 있는 내용을 Java - Object로 반환합니다.

---

## 2025-03-19 (JPA)
- QueryDSL은 오픈소스 프로젝트로, JPQL을 타입 안전하게 Java 코드로 작성할 수 있도록 도와주는 라이브러리
- JPA와 함께 사용되며, SQL과 유사한 쿼리를 Java 코드 기반으로 생성할 수 있음.

### 사용 이유
1. 컴파일 타임에 오류를 잡을 수 있어, 실행 시 발생하는 SQL 오류를 줄일 수 있음.
2. 문자열 기반 JPQL보다 가독성이 좋고 유지보수가 쉬움.
3. BooleanBuilder 등을 활용하여 조건에 따라 동적으로 쿼리를 조합할 수 있음.
4. 복잡한 동적 쿼리를 쉽게 다룰 수 있음.

---

## 2025-03-20 (STOMP) -> Simple Text Oriented Messaging Protocol
- 메시지 브로커와 클라이언트 간의 통신을 위한 텍스트 기반 메시징 프로토콜

### 특징
1. 메시지를 JSON, XML, 일반 텍스트 등 다양한 형식으로 주고받음
2. 다양한 프로그래밍 언어와 메시지 브로커(RabbitMQ)에서 지원됨
3. 특정 주제(Topic)나 큐(Queue)에 메시지를 보내면, 해당 주제를 구독하는 모든 클라이언트가 메시지를 받을 수 있음
4. pub/sub -> publisher가 특정 topic에 메세지를 보내면 해당 topic을 구독하고 있는 subsciber 모두에게 메세지가 전달되는 구조

---

## 2025-03-21 (검색)
### IKE Search
- LIKE '%keyword%' 또는 정규 표현식을 이용한 검색
- 데이터가 많아질수록 느려짐
- 정확히 일치하는 문자열만 가능
- 기본적인 정렬/필터링만 가능
- 그래서 단순한 텍스트 검색에 사용함

### Elastic Search (역색인)
- 대용량 데이터에도 빠름
- 형태소 분석을 이용해 유사 단어도 검색 가능
- 다양한 조건을 추가하여 검색 최적화 가능
- 그래서 대용량 문서 검색, 추천 시스템에 사용함

#### 역색인 과정
1. 토큰화 -> 문서를 단어(토큰)로 분리한다.  
    - `"나는 축구를 좋아한다"` → `["나는", "축구", "좋아한다"]`
2. 정규화 -> 단어를 표준화해서 색인 생성 시 검색 정확도를 높인다.  
    - `"축구"`와 `"football"`을 같은 의미로 저장하거나 `"사랑합니다"`를 `"사랑"`으로 변환한다.
3. 역색인 생성 -> 각 단어가 포함된 문서를 저장하여 빠른 검색 가능.
4. 검색(Query) 실행 시 빠른 조회  
    - `"축구"`를 검색하면 바로 해당하는 문서 리스트(1, 2, 3번 문서)를 반환.

---

## 2025-03-24 (spring)
### AuthenticationPrincipal
- spring Security에서 인증된 사용자의 정보를 컨트롤러에서 편리하게 가져올 수 있도록 제공하는 어노테이션

### 특징
1. 인증된 사용자 정보를 컨트롤러의 메서드 인자로 바로 주입 가능
2. SecurityContextHolder에서 직접 Authentication 객체를 가져오는 번거로움을 줄여줌

---

## 2025-03-25 (spring)
### Filter
- Filter는 HTTP 요청과 응답을 가로채서 특정 로직을 수행할 수 있는 기능을 제공하는 컴포넌트다.
주로 보안, CORS 설정, 인증 등에서 사용된다.

### 동작 방식
1. Spring에서 Filter는 DispatcherServlet이 처리하기 전에 실행된다.
2. Filter → DispatcherServlet → Controller 순서로 요청이 전달된다.

### 흐름
1. 요청이 들어오면 가장 먼저 Filter가 실행된다.
2. 여러 개의 필터가 있을 경우 FilterChain을 따라 순차적으로 실행된다.
3. Filter에서 특정 조건에 따라 요청을 차단하거나 수정할 수 있다.
4. 모든 필터가 실행된 후, DispatcherServlet이 실행되며 컨트롤러로 요청을 넘긴다.
5. 컨트롤러에서 응답이 반환되면, Filter가 응답을 가로채서 수정할 수도 있다.

---

## 2025-03-26 (FCM)
- Google Firebase에서 제공하는 무료 푸시 알림 서비스
- 모바일 앱이나 웹 애플리케이션에서 푸시 알림을 보낼 때 사용
- 특정 사용자, 그룹, 또는 전체 사용자에게 메시지 전송 가능

### 메시지 흐름
1. 백엔드 서버에서 FCM 서버로 메시지 전송
2. FCM 서버가 푸시 메시지를 클라이언트 앱으로 전달
3. 클라이언트 앱이 푸시 메시지를 수신하고 알림을 표시하거나 데이터를 처리

--- 

## 2025-03-27 (rabbitMQ)
- AMQP를 기반으로 한 오픈 소스 메시지 브로커 - Advanced Message Queuing Protocol

### 구조
1. Producer (생산자)
- 메시지를 생성하여 Exchange로 보낸다.

2. Exchange (교환기)
- Producer가 보낸 메시지를 Queue로 라우팅하는 역할
- 메시지를 받을 Queue를 결정하는 Routing Key를 사용

3. Queue (큐)
- 메시지가 저장되는 공간
- Consumer가 메시지를 가져가 처리한다.

4. Consumer (소비자)
- Queue에서 메시지를 가져와 처리하는 역할

5. Binding
- Exchange와 Queue를 연결하는 설정
- 특정 조건에 맞는 메시지만 Queue에 전달할 수 있도록 설정 가능

### 예시
1. 비동기 처리 → 이메일, 알림, 대량 데이터 처리
2. 마이크로서비스 간 통신 → 결제, 주문, 배송 서비스 연동
3. 실시간 알림 → 푸시 알림, 채팅

---

## 2025-03-28 (JPA)
- Java 애플리케이션에서 관계형 데이터베이스를 객체 지향적으로 다룰 수 있도록 도와주는 ORM 기술
- 객체와 데이터베이스 테이블을 자동으로 매핑

### 주요 Annotation
1. @Entity -> 해당 클래스를 JPA 엔티티로 선언
2. @Table(name="테이블명") -> 테이블명을 지정
3. @Id -> 기본 키 지정
4. @GeneratedValue(strategy = GenerationType.IDENTITY) -> AUTO_INCREMENT
5. @Column(name="컬럼명") -> 특정 컬럼 이름 매핑, 속성 지정 가능
6. @ManyToOne -> 다 대 일 관계
7. @JoinColumn(name="컬럼명") -> 외래키 매핑

---

## 2025-03-31 (알고리즘)

### 최단경로
1. 다익스트라 알고리즘
- 그래프에서 한 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘
- 음의 가중치를 허용하지 않음

-> 정점 중심이기 때문에 인접행렬, 인접 리스트 이용해서 구현한다.

---

## 2025-04-01 (Axios)
- 백엔드와 통신할 때 사용되는 Promise 기반 HTTP 클라이언트
- 브라우저와 Node.js 환경에서 모두 동작하며, HTTP 요청을 쉽게 보낼 수 있도록 도와줌
- Rest API와 통신할 때 사용

### 특징
1. Promise 기반 → async/await을 활용하여 비동기 요청 처리 가능
2. 자동 JSON 변환 → 응답 데이터를 자동으로 JSON 형태로 변환
3. 요청 취소 기능 → CancelToken을 사용하여 요청 중단 가능
4.  인터셉터 기능 → 요청 또는 응답을 가로채서 추가적인 작업 수행 가능
5. 기본 URL 및 헤더 설정 가능 → axios.create()를 사용하여 기본 설정 가능
6. Get, Post, Delete, Put를 사용하여 통신

---

## 2025-04-02 (Cookie)
- 서버에서 사용자의 컴퓨터에 저장하는 정보파일
- 사용자가 별도의 요청을 하지 않아도 브라우저는 request시 request Header에 넣어 자동으로 서버에 전송
- Key와 Value로 구성되고 String 형태로 이루어짐

### 사용 목적
1. 세션관리 - 사용자 아이디, 접속 시간, 장바구니 등의 서버가 알아야 할 정보 저장
2. 개인화 - 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있음
3. 트래킹 - 사용자의 행동과 패턴을 분석하고 기록

### 동작 순서
1. Client가 페이지를 요청
2. WAS는 Cookie를 생성
3. HTTP Header에 Cookie를 넣어 응답
4. Browser는 넘겨받은 Cookie를 PC에 저장하고, 다시 WAS가 요청할 때 요청과 함께 Cookie를 전송
5. Browser가 종료되어도 Cookie의 만료 기간이 남아 있으면 Client는 계속 보관
6. 동일 사이트 재방문시 Client의 PC에 해당 Cookie가 있는 경우, 요청 페이지와 함께 Cookie를 전송

---

## 2025-04-03 (Spring)

### Request Mapping에서 Dto를 사용하면 좋은 점

#### 개별 파라미터
1. 파라미터 개수가 많아지면 코드가 길어지고 가독성이 떨어짐
2. 추가 필드가 생길 때마다 메서드의 매개변수를 계속 수정해야 함

#### Dto
1. 코드가 더 깔끔해지고 가독성이 향상됨
2. 필드가 추가되더라도 메서드의 매개변수를 수정할 필요 없음
3. 객체로 한 번에 전달할 수 있어 유지보수성이 뛰어남
4. @Valid, @Validated 어노테이션을 사용하면 DTO를 통해 입력값을 검증 가능

---

## 2025-04-07 (Java)

### 객체 지향 설계의 5가지 원칙 - SOLID
1. SRP - 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다 (응집도는 높이고 결합도는 낮춘다, 유지보수가 용이해야 한다)

2. OCP - 개방 폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다 (확장이 쉬워야 한다)

3. LSP - 리스코프 치환 원칙
- 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다 (다형성 지원한다)

4. ISP - 인터페이스 분리 원칙
- 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다 (인터페이스를 구체적이고 작은
단위들로 분리시킨다)

5. DIP - 의존관계 역전 원칙
- 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다 (인터페이스 활용한다)

---

## 2025-04-08 (Front)

### Vite
- 빠른 개발 환경을 제공하는 차세대 프론트엔드 빌드 툴

### 사용 이유
1. 빠른 개발 서버
- ES Module 기반으로 브라우저가 직접 import 해서 실행
- Webpack처럼 전체 앱을 번들링하지 않기 때문에, 시작 속도가 매우 빠름

2. 빠른 HMR - Hot Module Replacement
- 코드 변경 시, 바뀐 부분만 빠르게 새로고침됨
- 변경된 파일만 업데이트

3. 빌드 시에는 Rollup 사용
- vite build 시에는 Rollup 기반으로 최적화된 번들 생성

---

## 2025-04-09 (Front)

### TypeScript -> JavaScript + type 시스템
1. 자바스크립트에 정적 타입 검사 기능을 추가
2. 코드 작성 시점에 에러를 잡을 수 있음
3. .ts 확장자를 사용 -> JS와 완전히 호환된다.

### 왜 타입스크립트를 사용할까?
1. 타입 안정성
2. 자동완성
3. 리팩토링이 쉬움
4. 정적 분석 가능

---

## 2025-04-10 (Java)

### 결합도
- 하나의 모듈이 다른 모듈에 의존하는 정도

### 결합도 종류
1. 자료 결합도 -> 모듈끼리 단순히 데이터를 주고 받는 경우
2. 스탬프 결합도 -> 두 모듈이 인터페이스로 배열이나 오브젝트와 같은 동일한 자료 구조를 참조하는 형태의 결합도
3. 제어 결합도 -> 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하는 제어 요소를 전달하는 경우
4. 외부 결합도 -> 모듈이 외부에 있는 다른 모듈의 데이터를 참조할 때의 결합도
5. 공통 결합도 -> 여러 개의 모듈이 하나의 공통 데이터 영역을 사용하는 결합도
6. 내용 결합도 -> 어떤 모듈이 사용하려면 다른 모듈 내부 기능과 데이터를 직접 참조해 그대로 가져와 사용하거나 수정하는 경우

-> 결합도는 낮아야 좋음 == 자료 결합도가 가장 좋음

### 응집도
- 하나의 클래스가 기능에 집중하기 위한 모든 정보와 역할을 갖고 있어야 함

### 응집도 종류
1. 기능적 응집도 -> 모듈 내부의 모든 기능이 단일 목적을 위해 수행되는 경우
2. 순차적 응집도 -> 모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우
3. 교환적 응집도 -> 동일한 입력과 출력을 사용해 다른 기능을 수행하는 활동들이 모여있을 경우
4. 절차적 응집도 -> 모듈이 다수 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
5. 시간적 응집도 -> 연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
6. 논리적 응집도 -> 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
7. 우연적 응집도 -> 모듈 내부의 각 구성요소들이 연관이 없을 경우

-> 응집도는 높아야 좋음 == 기능적 응집도가 가장 좋음













